diff --git a/benchmarks/checked/curl/lib/http.c b/benchmarks/checked/curl/lib/http.c
index 1f84725..335eaf7 100644
--- a/benchmarks/checked/curl/lib/http.c
+++ b/benchmarks/checked/curl/lib/http.c
@@ -2069,7 +2069,7 @@ CURLcode Curl_http_useragent(struct Curl_easy *data)
      with the user-agent string specified, we erase the previously made string
      here. */
   if(Curl_checkheaders(data, "User-Agent")) {
-    free(data->state.aptr.uagent);
+    MM_FREE(char, data->state.aptr.uagent);
     data->state.aptr.uagent = NULL;
   }
   return CURLE_OK;
@@ -2282,7 +2282,7 @@ CURLcode Curl_http_target(struct Curl_easy *data,
 }
 
 CURLcode Curl_http_body(struct Curl_easy *data, struct connectdata *conn,
-                        Curl_HttpReq httpreq, const char **tep)
+                        Curl_HttpReq httpreq, mm_array_ptr<const char> *tep)
 {
   CURLcode result = CURLE_OK;
   mm_array_ptr<const char> ptr = NULL;
@@ -2771,24 +2771,24 @@ CURLcode Curl_http_range(struct Curl_easy *data,
     if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
        !Curl_checkheaders(data, "Range")) {
       /* if a line like this was already allocated, free the previous one */
-      free(data->state.aptr.rangeline);
-      data->state.aptr.rangeline = aprintf("Range: bytes=%s\r\n",
-                                           _GETCHARPTR(data->state.range));
+      MM_FREE(char, data->state.aptr.rangeline);
+      data->state.aptr.rangeline = mmize_str(aprintf("Range: bytes=%s\r\n",
+                                           _GETCHARPTR(data->state.range)));
     }
     else if((httpreq == HTTPREQ_POST || httpreq == HTTPREQ_PUT) &&
             !Curl_checkheaders(data, "Content-Range")) {
 
       /* if a line like this was already allocated, free the previous one */
-      free(data->state.aptr.rangeline);
+      MM_FREE(char, data->state.aptr.rangeline);
 
       if(data->set.set_resume_from < 0) {
         /* Upload resume was asked for, but we don't know the size of the
            remote part so we tell the server (and act accordingly) that we
            upload the whole file (again) */
         data->state.aptr.rangeline =
-          aprintf("Content-Range: bytes 0-%" CURL_FORMAT_CURL_OFF_T
+          mmize_str(aprintf("Content-Range: bytes 0-%" CURL_FORMAT_CURL_OFF_T
                   "/%" CURL_FORMAT_CURL_OFF_T "\r\n",
-                  data->state.infilesize - 1, data->state.infilesize);
+                  data->state.infilesize - 1, data->state.infilesize));
 
       }
       else if(data->state.resume_from) {
@@ -2796,17 +2796,17 @@ CURLcode Curl_http_range(struct Curl_easy *data,
         curl_off_t total_expected_size =
           data->state.resume_from + data->state.infilesize;
         data->state.aptr.rangeline =
-          aprintf("Content-Range: bytes %s%" CURL_FORMAT_CURL_OFF_T
+          mmize_str(aprintf("Content-Range: bytes %s%" CURL_FORMAT_CURL_OFF_T
                   "/%" CURL_FORMAT_CURL_OFF_T "\r\n",
                   _GETCHARPTR(data->state.range), total_expected_size-1,
-                  total_expected_size);
+                  total_expected_size));
       }
       else {
         /* Range was selected and then we just pass the incoming range and
            append total size */
         data->state.aptr.rangeline =
-          aprintf("Content-Range: bytes %s/%" CURL_FORMAT_CURL_OFF_T "\r\n",
-                  _GETCHARPTR(data->state.range), data->state.infilesize);
+          mmize_str(aprintf("Content-Range: bytes %s/%" CURL_FORMAT_CURL_OFF_T "\r\n",
+                  _GETCHARPTR(data->state.range), data->state.infilesize));
       }
       if(!data->state.aptr.rangeline)
         return CURLE_OUT_OF_MEMORY;
@@ -2985,7 +2985,7 @@ CURLcode Curl_transferencode(struct Curl_easy *data)
     mm_array_ptr<char> cptr = Curl_checkheaders(data, "Connection");
 #define TE_HEADER "TE: gzip\r\n"
 
-    Curl_safefree(data->state.aptr.te);
+    mm_Curl_safefree(char, data->state.aptr.te);
 
     if(cptr) {
       cptr = Curl_copy_header_value(cptr);
@@ -2994,9 +2994,9 @@ CURLcode Curl_transferencode(struct Curl_easy *data)
     }
 
     /* Create the (updated) Connection: header */
-    data->state.aptr.te = aprintf("Connection: %s%sTE\r\n" TE_HEADER,
+    data->state.aptr.te = mmize_str(aprintf("Connection: %s%sTE\r\n" TE_HEADER,
                                 _GETCHARPTR(cptr) ? _GETCHARPTR(cptr) : "",
-                                (_GETCHARPTR(cptr) && *cptr) ? ", ":"");
+                                (_GETCHARPTR(cptr) && *cptr) ? ", ":""));
 
     MM_FREE(char, cptr);
     if(!data->state.aptr.te)
@@ -3018,11 +3018,11 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
   CURLcode result = CURLE_OK;
   mm_ptr<struct HTTP> http = NULL;
   Curl_HttpReq httpreq;
-  const char *te = ""; /* transfer-encoding */
+  mm_array_ptr<const char> te = ""; /* transfer-encoding */
   mm_array_ptr<const char> request = NULL;
   const char *httpstring;
   struct dynbuf req;
-  char *altused = NULL;
+  mm_array_ptr<char> altused = NULL;
   const char *p_accept;      /* Accept: string */
 
   /* Always consider the DO phase done after this function call, even if there
@@ -3103,23 +3103,23 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
       return result;
   }
 
-  Curl_safefree(data->state.aptr.ref);
+  mm_Curl_safefree(char, data->state.aptr.ref);
   if(data->state.referer && !Curl_checkheaders(data, "Referer")) {
-    data->state.aptr.ref = aprintf("Referer: %s\r\n", data->state.referer);
+    data->state.aptr.ref = mmize_str(aprintf("Referer: %s\r\n", data->state.referer));
     if(!data->state.aptr.ref)
       return CURLE_OUT_OF_MEMORY;
   }
 
   if(!Curl_checkheaders(data, "Accept-Encoding") &&
      data->set.str[STRING_ENCODING]) {
-    Curl_safefree(data->state.aptr.accept_encoding);
+    mm_Curl_safefree(char, data->state.aptr.accept_encoding);
     data->state.aptr.accept_encoding =
-      aprintf("Accept-Encoding: %s\r\n", _GETCHARPTR(data->set.str[STRING_ENCODING]));
+      mmize_str(aprintf("Accept-Encoding: %s\r\n", _GETCHARPTR(data->set.str[STRING_ENCODING])));
     if(!data->state.aptr.accept_encoding)
       return CURLE_OUT_OF_MEMORY;
   }
   else
-    Curl_safefree(data->state.aptr.accept_encoding);
+    mm_Curl_safefree(char, data->state.aptr.accept_encoding);
 
 #ifdef HAVE_LIBZ
   /* we only consider transfer-encoding magic if libz support is built-in */
@@ -3163,8 +3163,8 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
 
 #ifndef CURL_DISABLE_ALTSVC
   if(conn->bits.altused && !Curl_checkheaders(data, "Alt-Used")) {
-    altused = aprintf("Alt-Used: %s:%d\r\n",
-                      _GETCHARPTR(conn->conn_to_host.name), conn->conn_to_port);
+    altused = mmize_str(aprintf("Alt-Used: %s:%d\r\n",
+                      _GETCHARPTR(conn->conn_to_host.name), conn->conn_to_port));
     if(!altused) {
       Curl_dyn_free(&req);
       return CURLE_OUT_OF_MEMORY;
@@ -3193,19 +3193,19 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
                   _GETCHARPTR(data->state.aptr.proxyuserpwd):"",
                   data->state.aptr.userpwd?_GETCHARPTR(data->state.aptr.userpwd):"",
                   (data->state.use_range && data->state.aptr.rangeline)?
-                  data->state.aptr.rangeline:"",
+                  _GETCHARPTR(data->state.aptr.rangeline):"",
                   (data->set.str[STRING_USERAGENT] &&
                    *data->set.str[STRING_USERAGENT] &&
                    data->state.aptr.uagent)?
-                  data->state.aptr.uagent:"",
+                  _GETCHARPTR(data->state.aptr.uagent):"",
                   p_accept?p_accept:"",
-                  data->state.aptr.te?data->state.aptr.te:"",
+                  data->state.aptr.te?_GETCHARPTR(data->state.aptr.te):"",
                   (data->set.str[STRING_ENCODING] &&
                    *data->set.str[STRING_ENCODING] &&
                    data->state.aptr.accept_encoding)?
-                  data->state.aptr.accept_encoding:"",
+                  _GETCHARPTR(data->state.aptr.accept_encoding):"",
                   (data->state.referer && data->state.aptr.ref)?
-                  data->state.aptr.ref:"" /* Referer: <data> */,
+                  _GETCHARPTR(data->state.aptr.ref):"" /* Referer: <data> */,
 #ifndef CURL_DISABLE_PROXY
                   (conn->bits.httpproxy &&
                    !conn->bits.tunnel_proxy &&
@@ -3215,15 +3215,15 @@ CURLcode Curl_http(struct Curl_easy *data, bool *done)
 #else
                   "",
 #endif
-                  te,
-                  altused ? altused : ""
+                  _GETCHARPTR(te),
+                  altused ? _GETCHARPTR(altused) : ""
       );
 
   /* clear userpwd and proxyuserpwd to avoid re-using old credentials
    * from re-used connections */
   mm_Curl_safefree(char, data->state.aptr.userpwd);
   mm_Curl_safefree(char, data->state.aptr.proxyuserpwd);
-  free(altused);
+  MM_FREE(char, altused);
 
   if(result) {
     Curl_dyn_free(&req);
diff --git a/benchmarks/checked/curl/lib/http.h b/benchmarks/checked/curl/lib/http.h
index 660bf80..432dd10 100644
--- a/benchmarks/checked/curl/lib/http.h
+++ b/benchmarks/checked/curl/lib/http.h
@@ -100,7 +100,7 @@ CURLcode Curl_http_header(struct Curl_easy *data, struct connectdata *conn,
 CURLcode Curl_transferencode(struct Curl_easy *data);
 CURLcode Curl_http_body(struct Curl_easy *data, struct connectdata *conn,
                         Curl_HttpReq httpreq,
-                        const char **teep);
+                        mm_array_ptr<const char> *teep);
 CURLcode Curl_http_bodysend(struct Curl_easy *data, struct connectdata *conn,
                             mm_ptr<struct dynbuf> r, Curl_HttpReq httpreq);
 bool Curl_use_http_1_1plus(const struct Curl_easy *data,
diff --git a/benchmarks/checked/curl/lib/multi.c b/benchmarks/checked/curl/lib/multi.c
index 4bcec2d..c376f4b 100644
--- a/benchmarks/checked/curl/lib/multi.c
+++ b/benchmarks/checked/curl/lib/multi.c
@@ -1880,7 +1880,6 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         data->state.async.done = TRUE;
 #endif
         result = CURLE_OK;
-        // TODO
         infof(data, "Hostname '%s' was found in DNS cache", _GETCHARPTR(hostname));
       }
 
diff --git a/benchmarks/checked/curl/lib/rtsp.c b/benchmarks/checked/curl/lib/rtsp.c
index 22165ca..77dfaa6 100644
--- a/benchmarks/checked/curl/lib/rtsp.c
+++ b/benchmarks/checked/curl/lib/rtsp.c
@@ -250,14 +250,14 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
   curl_off_t putsize = 0; /* for ANNOUNCE and SET_PARAMETER */
 
   mm_array_ptr<const char> p_request = NULL;
-  const char *p_session_id = NULL;
-  const char *p_accept = NULL;
-  const char *p_accept_encoding = NULL;
-  const char *p_range = NULL;
-  const char *p_referrer = NULL;
+  mm_array_ptr<const char> p_session_id = NULL;
+  mm_array_ptr<const char> p_accept = NULL;
+  mm_array_ptr<const char> p_accept_encoding = NULL;
+  mm_array_ptr<const char> p_range = NULL;
+  mm_array_ptr<const char> p_referrer = NULL;
   mm_array_ptr<const char> p_stream_uri = NULL;
-  const char *p_transport = NULL;
-  const char *p_uagent = NULL;
+  mm_array_ptr<const char> p_transport = NULL;
+  mm_array_ptr<const char> p_uagent = NULL;
   mm_array_ptr<const char> p_proxyuserpwd = NULL;
   mm_array_ptr<const char> p_userpwd = NULL;
 
@@ -324,8 +324,7 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
     return result;
   }
 
-  // TODO?
-  p_session_id = _GETCHARPTR(data->set.str[STRING_RTSP_SESSION_ID]);
+  p_session_id = data->set.str[STRING_RTSP_SESSION_ID];
   if(!p_session_id &&
      (rtspreq & ~(RTSPREQ_OPTIONS | RTSPREQ_DESCRIBE | RTSPREQ_SETUP))) {
     failf(data, "Refusing to issue an RTSP request [%s] without a session ID.",
@@ -342,16 +341,15 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
   }
 
   /* Transport Header for SETUP requests */
-  // TODO
-  p_transport = _GETCHARPTR(Curl_checkheaders(data, "Transport"));
+  p_transport = Curl_checkheaders(data, "Transport");
   if(rtspreq == RTSPREQ_SETUP && !p_transport) {
     /* New Transport: setting? */
     if(data->set.str[STRING_RTSP_TRANSPORT]) {
-      Curl_safefree(data->state.aptr.rtsp_transport);
+      mm_Curl_safefree(char, data->state.aptr.rtsp_transport);
 
       data->state.aptr.rtsp_transport =
-        aprintf("Transport: %s\r\n",
-                _GETCHARPTR(data->set.str[STRING_RTSP_TRANSPORT]));
+        mmize_str(aprintf("Transport: %s\r\n",
+                _GETCHARPTR(data->set.str[STRING_RTSP_TRANSPORT])));
       if(!data->state.aptr.rtsp_transport)
         return CURLE_OUT_OF_MEMORY;
     }
@@ -367,15 +365,15 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
   /* Accept Headers for DESCRIBE requests */
   if(rtspreq == RTSPREQ_DESCRIBE) {
     /* Accept Header */
-    p_accept = Curl_checkheaders(data, "Accept")?
-      NULL:"Accept: application/sdp\r\n";
+    if (Curl_checkheaders(data, "Accept")) p_accept = NULL;
+    else p_accept = "Accept: application/sdp\r\n";
 
     /* Accept-Encoding header */
     if(!Curl_checkheaders(data, "Accept-Encoding") &&
        data->set.str[STRING_ENCODING]) {
-      Curl_safefree(data->state.aptr.accept_encoding);
+      mm_Curl_safefree(char, data->state.aptr.accept_encoding);
       data->state.aptr.accept_encoding =
-        aprintf("Accept-Encoding: %s\r\n", _GETCHARPTR(data->set.str[STRING_ENCODING]));
+        mmize_str(aprintf("Accept-Encoding: %s\r\n", _GETCHARPTR(data->set.str[STRING_ENCODING])));
 
       if(!data->state.aptr.accept_encoding)
         return CURLE_OUT_OF_MEMORY;
@@ -389,7 +387,7 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
      with the user-agent string specified, we erase the previously made string
      here. */
   if(Curl_checkheaders(data, "User-Agent") && data->state.aptr.uagent) {
-    Curl_safefree(data->state.aptr.uagent);
+    mm_Curl_safefree(char, data->state.aptr.uagent);
     data->state.aptr.uagent = NULL;
   }
   else if(!Curl_checkheaders(data, "User-Agent") &&
@@ -407,9 +405,9 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
   p_userpwd = data->state.aptr.userpwd;
 
   /* Referrer */
-  Curl_safefree(data->state.aptr.ref);
+  mm_Curl_safefree(char, data->state.aptr.ref);
   if(data->state.referer && !Curl_checkheaders(data, "Referer"))
-    data->state.aptr.ref = aprintf("Referer: %s\r\n", data->state.referer);
+    data->state.aptr.ref = mmize_str(aprintf("Referer: %s\r\n", data->state.referer));
   else
     data->state.aptr.ref = NULL;
 
@@ -426,8 +424,8 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
 
     /* Check to see if there is a range set in the custom headers */
     if(!Curl_checkheaders(data, "Range") && data->state.range) {
-      Curl_safefree(data->state.aptr.rangeline);
-      data->state.aptr.rangeline = aprintf("Range: %s\r\n", _GETCHARPTR(data->state.range));
+      mm_Curl_safefree(char, data->state.aptr.rangeline);
+      data->state.aptr.rangeline = mmize_str(aprintf("Range: %s\r\n", _GETCHARPTR(data->state.range)));
       p_range = data->state.aptr.rangeline;
     }
   }
@@ -460,7 +458,7 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
    * to make comparison easier
    */
   if(p_session_id) {
-    result = Curl_dyn_addf(&req_buffer, "Session: %s\r\n", p_session_id);
+    result = Curl_dyn_addf(&req_buffer, "Session: %s\r\n", _GETCHARPTR(p_session_id));
     if(result)
       return result;
   }
@@ -478,12 +476,12 @@ static CURLcode rtsp_do(struct Curl_easy *data, bool *done)
                          "%s" /* proxyuserpwd */
                          "%s" /* userpwd */
                          ,
-                         p_transport ? p_transport : "",
-                         p_accept ? p_accept : "",
-                         p_accept_encoding ? p_accept_encoding : "",
-                         p_range ? p_range : "",
-                         p_referrer ? p_referrer : "",
-                         p_uagent ? p_uagent : "",
+                         p_transport ? _GETCHARPTR(p_transport) : "",
+                         p_accept ? _GETCHARPTR(p_accept) : "",
+                         p_accept_encoding ? _GETCHARPTR(p_accept_encoding) : "",
+                         p_range ? _GETCHARPTR(p_range) : "",
+                         p_referrer ? _GETCHARPTR(p_referrer) : "",
+                         p_uagent ? _GETCHARPTR(p_uagent) : "",
                          p_proxyuserpwd ? _GETCHARPTR(p_proxyuserpwd) : "",
                          p_userpwd ? _GETCHARPTR(p_userpwd) : "");
 
diff --git a/benchmarks/checked/curl/lib/slist.c b/benchmarks/checked/curl/lib/slist.c
index da24812..2b9e366 100644
--- a/benchmarks/checked/curl/lib/slist.c
+++ b/benchmarks/checked/curl/lib/slist.c
@@ -94,7 +94,6 @@ struct curl_slist *curl_slist_append(struct curl_slist *list,
   if(!dupdata)
     return NULL;
 
-  // TODO
   list = _GETPTR(struct curl_slist, Curl_slist_append_nodup(list, dupdata));
   if(!list)
     MM_FREE(char, dupdata);
@@ -113,7 +112,6 @@ struct curl_slist *Curl_slist_duplicate(struct curl_slist *inlist)
   struct curl_slist *tmp;
 
   while(inlist) {
-    // TODO
     tmp = _GETPTR(struct curl_slist, curl_slist_append(outlist, _GETCHARPTR(inlist->data)));
 
     if(!tmp) {
diff --git a/benchmarks/checked/curl/lib/transfer.c b/benchmarks/checked/curl/lib/transfer.c
index 4cf12c5..07e742b 100644
--- a/benchmarks/checked/curl/lib/transfer.c
+++ b/benchmarks/checked/curl/lib/transfer.c
@@ -1513,9 +1513,9 @@ CURLcode Curl_pretransfer(struct Curl_easy *data)
    * protocol.
    */
   if(data->set.str[STRING_USERAGENT]) {
-    Curl_safefree(data->state.aptr.uagent);
+    mm_Curl_safefree(char, data->state.aptr.uagent);
     data->state.aptr.uagent =
-      aprintf("User-Agent: %s\r\n", _GETCHARPTR(data->set.str[STRING_USERAGENT]));
+      mmize_str(aprintf("User-Agent: %s\r\n", _GETCHARPTR(data->set.str[STRING_USERAGENT])));
     if(!data->state.aptr.uagent)
       return CURLE_OUT_OF_MEMORY;
   }
diff --git a/benchmarks/checked/curl/lib/url.c b/benchmarks/checked/curl/lib/url.c
index 5ab2204..02ca0d0 100644
--- a/benchmarks/checked/curl/lib/url.c
+++ b/benchmarks/checked/curl/lib/url.c
@@ -451,15 +451,15 @@ CURLcode Curl_close(struct Curl_easy **datap)
   }
 
   mm_Curl_safefree(char, data->state.aptr.proxyuserpwd);
-  Curl_safefree(data->state.aptr.uagent);
+  mm_Curl_safefree(char, data->state.aptr.uagent);
   mm_Curl_safefree(char, data->state.aptr.userpwd);
-  Curl_safefree(data->state.aptr.accept_encoding);
-  Curl_safefree(data->state.aptr.te);
-  Curl_safefree(data->state.aptr.rangeline);
-  Curl_safefree(data->state.aptr.ref);
+  mm_Curl_safefree(char, data->state.aptr.accept_encoding);
+  mm_Curl_safefree(char, data->state.aptr.te);
+  mm_Curl_safefree(char, data->state.aptr.rangeline);
+  mm_Curl_safefree(char, data->state.aptr.ref);
   mm_Curl_safefree(char, data->state.aptr.host);
   mm_Curl_safefree(char, data->state.aptr.cookiehost);
-  Curl_safefree(data->state.aptr.rtsp_transport);
+  mm_Curl_safefree(char, data->state.aptr.rtsp_transport);
   mm_Curl_safefree(char, data->state.aptr.user);
   mm_Curl_safefree(char, data->state.aptr.passwd);
   mm_Curl_safefree(char, data->state.aptr.proxyuser);
@@ -467,8 +467,8 @@ CURLcode Curl_close(struct Curl_easy **datap)
 
 #ifndef CURL_DISABLE_DOH
   if(data->req.doh) {
-    Curl_dyn_free(_GETDYNBUFPTR(&data->req.doh->probe[0].serverdoh));
-    Curl_dyn_free(_GETDYNBUFPTR(&data->req.doh->probe[1].serverdoh));
+    mm_Curl_dyn_free(&data->req.doh->probe[0].serverdoh);
+    mm_Curl_dyn_free(&data->req.doh->probe[1].serverdoh);
     curl_slist_free_all(data->req.doh->headers);
     mm_Curl_safefree(struct dohdata, data->req.doh);
   }
diff --git a/benchmarks/checked/curl/lib/urlapi.c b/benchmarks/checked/curl/lib/urlapi.c
index 9fae737..a71dcde 100644
--- a/benchmarks/checked/curl/lib/urlapi.c
+++ b/benchmarks/checked/curl/lib/urlapi.c
@@ -2039,7 +2039,6 @@ CURLUcode mm_curl_url_set(CURLU *u, CURLUPart what,
         /* Skip hostname check, it's allowed to be empty. */
       }
       else {
-        // TODO
         if(hostname_check(u, (char *)newp)) {
           MM_FREE(char, newp);
           return CURLUE_MALFORMED_INPUT;
diff --git a/benchmarks/checked/curl/lib/urldata.h b/benchmarks/checked/curl/lib/urldata.h
index 776a458..685e3aa 100644
--- a/benchmarks/checked/curl/lib/urldata.h
+++ b/benchmarks/checked/curl/lib/urldata.h
@@ -1424,15 +1424,15 @@ struct UrlState {
      killed. */
   struct dynamically_allocated_data {
     mm_array_ptr<char> proxyuserpwd;
-    char *uagent;
-    char *accept_encoding;
+    mm_array_ptr<char> uagent;
+    mm_array_ptr<char> accept_encoding;
     mm_array_ptr<char> userpwd;
-    char *rangeline;
-    char *ref;
+    mm_array_ptr<char> rangeline;
+    mm_array_ptr<char> ref;
     mm_array_ptr<char> host;
     mm_array_ptr<char> cookiehost;
-    char *rtsp_transport;
-    char *te; /* TE: request header */
+    mm_array_ptr<char> rtsp_transport;
+    mm_array_ptr<char> te; /* TE: request header */
 
     /* transfer credentials */
     mm_array_ptr<char> user;
